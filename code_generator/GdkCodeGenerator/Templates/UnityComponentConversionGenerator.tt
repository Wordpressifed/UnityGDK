<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
    var eventDetailsList = GetEventDetailsList();
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Unity.Mathematics;
using Unity.Entities;
using Improbable.Worker.Core;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.CodegenAdapters;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
        public class DispatcherHandler : ComponentDispatcherHandler
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            private readonly EntityManager entityManager;

            private const string LoggerName = "<#= componentDetails.ComponentName #>.DispatcherHandler";

            public DispatcherHandler(MutableView mutableView) : base(mutableView)
            {
                entityManager = mutableView.EntityManager;
            }

            public override void OnAddComponent(AddComponentOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "AddComponentOp")
                    );
                    return;
                }
                entityManager.AddComponentData(entity, global::<#= qualifiedNamespace #>.<#= componentDetails.TypeName #>.Serialization.Deserialize(op.Data.SchemaData.Value.GetFields()));

                if (entityManager.HasComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.RemoveComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.AddComponentData(entity, new ComponentAdded<<#= componentDetails.TypeName #>>());
                }
                else 
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentAdded)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                    );
                }
            }

            public override void OnRemoveComponent(RemoveComponentOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "RemoveComponentOp")
                    );
                    return;
                }
                entityManager.RemoveComponent<<#= componentDetails.TypeName #>>(entity);

                if (entityManager.HasComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.RemoveComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.AddComponentData(entity, new ComponentRemoved<<#= componentDetails.TypeName #>>());
                }
                else 
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentRemoved)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                    );
                }
            }

            public override void OnComponentUpdate(ComponentUpdateOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "ComponentUpdateOp")
                    );
                    return;
                }
                var data = entityManager.GetComponentData<<#= componentDetails.TypeName #>>(entity);

                var update = global::<#= qualifiedNamespace #>.<#= componentDetails.TypeName #>.Serialization.GetAndApplyUpdate(op.Update.SchemaData.Value.GetFields(), ref data);

                // TODO: Events?

                entityManager.SetComponentData(entity, data);
                // TODO: Add update to the list? 
            }

            public override void OnAuthorityChange(AuthorityChangeOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "AuthorityChangeOp")
                    );
                    return;
                }
                ApplyAuthorityChange(entity, op.Authority, op.EntityId.Id);
            }

            public override void OnCommandRequest(CommandRequestOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "CommandRequestOp")
                    );
                    return;
                }

                var commandIndex = op.Request.SchemaData.Value.GetCommandIndex();
                switch (commandIndex)
                {
<# foreach(var commandDetails in commandDetailsList) { #>
                    case <#= commandDetails.CommandIndex #>:
                        On<#= commandDetails.CommandName #>Request(op);
                        break;
<# } #>
                    default:
                        LogDispatcher.HandleLog(LogType.Error, new LogEvent(CommandIndexNotFound)
                            .WithField(LoggingUtils.LoggerName, LoggerName)
                            .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                            .WithField("CommandIndex", commandIndex)
                        );
                        break;
                }
            }

            public override void OnCommandResponse(CommandResponseOp op)
            {
                if (MutableView.TryGetEntity(op.EntityId, out var entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Op", "CommandResponseOp")
                    );
                    return;
                }

                var commandIndex = op.Response.SchemaData.Value.GetCommandIndex();
                switch (commandIndex)
                {
<# foreach(var commandDetails in commandDetailsList) { #>
                    case <#= commandDetails.CommandIndex #>:
                        On<#= commandDetails.CommandName #>Response(op);
                        break;
<# } #>
                    default:
                        LogDispatcher.HandleLog(LogType.Error, new LogEvent(CommandIndexNotFound)
                            .WithField(LoggingUtils.LoggerName, LoggerName)
                            .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                            .WithField("CommandIndex", commandIndex)
                        );
                        break;
                }
            }

            private void ApplyAuthorityChange(Unity.Entities.Entity entity, Authority authority, long entityId)
            {
                switch (authority)
                {
                    case Authority.Authoritative:
                        if (!entityManager.HasComponent<NotAuthoritative<<#= componentDetails.TypeName #>>>(entity)) 
                        {
                            LogDispatcher.HandleLog(LogType.Error, new LogEvent(InvalidAuthorityChange)
                                .WithField(LoggingUtils.LoggerName, LoggerName)
                                .WithField(LoggingUtils.EntityId, entityId)
                                .WithField("Authority", Authority.Authoritative)
                            );
                            return;
                        }

                        entityManager.RemoveComponent<NotAuthoritative<<#= componentDetails.TypeName #>>>(entity);
                        entityManager.AddComponentData(entity, new Authoritative<<#= componentDetails.TypeName #>>());
                        break;
                    case Authority.AuthorityLossImminent:
                        if (!entityManager.HasComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity)) 
                        {
                            LogDispatcher.HandleLog(LogType.Error, new LogEvent(InvalidAuthorityChange)
                                .WithField(LoggingUtils.LoggerName, LoggerName)
                                .WithField(LoggingUtils.EntityId, entityId)
                                .WithField("Authority", Authority.AuthorityLossImminent)
                            );
                            return;
                        }
                        entityManager.AddComponentData(entity, new AuthorityLossImminent<<#= componentDetails.TypeName #>>());
                        break;
                    case Authority.NotAuthoritative:
                        if (!entityManager.HasComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity))
                        {
                            LogDispatcher.HandleLog(LogType.Error, new LogEvent(InvalidAuthorityChange)
                                .WithField(LoggingUtils.LoggerName, LoggerName)
                                .WithField(LoggingUtils.EntityId, entityId)
                                .WithField("Authority", Authority.NotAuthoritative)
                            );
                            return;
                        }

                        if (entityManager.HasComponent<AuthorityLossImminent<<#= componentDetails.TypeName #>>>(entity))
                        {
                            entityManager.RemoveComponent<AuthorityLossImminent<<#= componentDetails.TypeName #>>>(entity);
                        }

                        entityManager.RemoveComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity);
                        entityManager.AddComponentData(entity, new NotAuthoritative<<#= componentDetails.TypeName #>>());
                        break;
                }

                // TODO: Add to authorities changed list
            }
<# foreach (var command in commandDetailsList) { #>
            private void On<#= command.CommandName #>Request(CommandRequestOp op)
            {
                // TODO: Implement commands
            }

            private void On<#= command.CommandName #>Response(CommandResponseOp op)
            {
                // TODO: Implement commands
            }
<# } #>
        }

        public class ComponentReplicator : ComponentReplicationHandler 
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            public override ComponentType[] ReplicationComponentTypes => new ComponentType[] {
                typeof(<#= componentDetails.TypeName #>), 
                typeof(Authoritative<<#= componentDetails.TypeName #>>), 
                typeof(SpatialEntityId)
            };

            public override ComponentType[] CommandTypes => new ComponentType[] {
<# foreach (var command in commandDetailsList) { #>

<# } #>
            };

            public ComponentReplicator(EntityManager entityManager) : base(entityManager)
            {
            }

            public override void ExecuteReplication(ComponentGroup replicationGroup, Connection connection)
            {
                var componentData = replicationGroup.GetComponentDataArray<<#= componentDetails.TypeName #>>();
                var entityIdData = replicationGroup.GetComponentDataArray<SpatialEntityId>();

                for (var i = 0; i < componentData.Length; i++) 
                {
                    var data = componentData[i];
                    if (data.DirtyBit)
                    {
                        var update = new global::Improbable.Worker.Core.SchemaComponentUpdate(<#= componentDetails.ComponentId #>);
                        <#= componentDetails.TypeName #>.Serialization.Serialize(data, update.GetFields());
                        connection.SendComponentUpdate(entityIdData[i].EntityId, new global::Improbable.Worker.Core.ComponentUpdate(update));

                        // TODO: Generate event serialization into update

                        data.DirtyBit = false;
                        componentData[i] = data;
                    }
                }
            }

            public override void SendCommands(List<ComponentGroup> commandComponentGroups, Connection connection)
            {
                // TODO: Generate command serialization
            }

        }

        public class ComponentCleanup : ComponentCleanupHandler 
        {
            public override ComponentType[] CleanUpComponentTypes => cleanUpComponentTypes;
            private static readonly ComponentType[] cleanUpComponentTypes = {
                typeof(ComponentAdded<<#= componentDetails.TypeName #>>),
                typeof(ComponentRemoved<<#= componentDetails.TypeName #>>)
                // TODO: More to come potentially
            };
        }
    }

}
